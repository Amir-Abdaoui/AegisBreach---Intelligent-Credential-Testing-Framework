from ast import List
from typing import Dict

from click import Tuple

from Orchestrator import AttackMode, TargetConfig


class IntelligenceEngine:
    def __init__(self):
        self.patterns = {}
        self.learned_rules = []
        self.password_models = {}
        
    def analyze_target(self, target: TargetConfig) -> Dict:
        """Analyze target for patterns and weaknesses"""
        analysis = {
            'response_patterns': {},
            'estimated_security_level': 'medium',
            'suggested_approach': 'hybrid'
        }
        
        # Analyze response times for timing attacks
        # Analyze error messages for information leakage
        # Check for security headers
        
        return analysis
    
    def generate_strategy(self, analysis: Dict, mode: AttackMode) -> Dict:
        """Generate attack strategy based on analysis"""
        strategy = {
            'mode': mode,
            'primary_technique': 'probabilistic_dictionary',
            'secondary_technique': 'rule_based_mutation',
            'pace': 'adaptive',
            'evasion_level': 'high'
        }
        
        if mode == AttackMode.STEALTH:
            strategy.update({
                'requests_per_minute': 5,
                'jitter': 'high',
                'ip_rotation': True
            })
        elif mode == AttackMode.INTELLIGENT:
            strategy.update({
                'use_ai_patterns': True,
                'context_aware': True,
                'dynamic_adaptation': True
            })
        
        return strategy
    
    def learn_from_response(self, response: Dict, current_strategy: Dict):
        """Learn from server responses to improve strategy"""
        response_time = response.get('response_time', 0)
        
        # Detect patterns in response times (potential for timing attacks)
        if response_time > 2.0:  # Slow response
            self.patterns.setdefault('slow_responses', []).append(response_time)
        
        # Learn from error messages
        if 'error' in response:
            error_msg = response['error'].lower()
            if 'locked' in error_msg or 'blocked' in error_msg:
                self.learned_rules.append('account_lockout_detected')
            elif 'rate limit' in error_msg:
                self.learned_rules.append('rate_limiting_active')
    
    def adapt_strategy(self, current_strategy: Dict) -> Dict:
        """Adapt strategy based on learned patterns"""
        if 'account_lockout_detected' in self.learned_rules:
            current_strategy['pace'] = 'very_slow'
            current_strategy['evasion_level'] = 'maximum'
            current_strategy['ip_rotation'] = True
        
        if 'rate_limiting_active' in self.learned_rules:
            # Switch to low-and-slow mode
            current_strategy['requests_per_minute'] = 2
            current_strategy['jitter'] = 'random'
        
        return current_strategy
    
    def generate_probabilistic_wordlist(self, base_words: List[str], 
                                        context: Dict = None) -> List[Tuple[str, float]]:
        """Generate weighted wordlist based on context"""
        weighted = []
        
        for word in base_words:
            weight = 1.0
            
            # Adjust weight based on context
            if context:
                if context.get('language') == 'english':
                    # English common passwords
                    if word in ['password', '123456', 'qwerty']:
                        weight *= 2.0
                
                if context.get('year'):
                    # Favor passwords with recent years
                    if str(context['year']) in word:
                        weight *= 1.5
            
            weighted.append((word, weight))
        
        # Sort by weight
        weighted.sort(key=lambda x: x[1], reverse=True)
        return weighted